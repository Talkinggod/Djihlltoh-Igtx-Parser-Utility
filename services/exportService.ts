

import { ParseReport } from '../types';

export type ExportFormat = 'json' | 'txt' | 'csv' | 'latex' | 'elan' | 'flex';

export function generateExportContent(report: ParseReport, format: ExportFormat): { content: string, type: string, ext: string } {
    let content = '';
    let type = '';
    let ext = '';

    switch (format) {
        case 'json':
            // Corrected property access for igtxDocument
            content = JSON.stringify(report.igtxDocument || {}, null, 2);
            type = 'application/json';
            ext = 'json';
            break;
        case 'txt':
            content = report.fullExtractedText;
            type = 'text/plain';
            ext = 'txt';
            break;
        case 'csv':
             // Headers: Block ID, Raw Source, Extracted Text, Confidence, Warnings, Position, Source URL
             const headers = ["Block ID", "Raw Source", "Extracted Text", "Confidence", "Warnings", "Position", "Source URL"];
             const rows = report.blocks.map(block => [
                block.id,
                `"${block.rawSource.replace(/"/g, '""')}"`,
                `"${block.extractedLanguageLine.replace(/"/g, '""')}"`,
                block.confidence.toFixed(2),
                // Corrected property access for warnings
                `"${(block.warnings || []).join('; ')}"`,
                block.lineNumber.toString(),
                // Corrected property access for igtxDocument source url
                `"${report.igtxDocument?.source?.source_url || ""}"`
             ]);
             content = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
             type = 'text/csv';
             ext = 'csv';
             break;
        case 'latex':
             // Generate gb4e format
             const latexBlocks = report.blocks.map(b => 
`\\begin{exe}
  \\ex
  \\glll {${b.extractedLanguageLine}} \\\\
         {} \\\\
         {} \\\\
\\end{exe}`
             ).join('\n\n');
             // Corrected property access for igtxDocument id
             content = `% Generated by Dziłtǫ́ǫ́ IGT Parser\n% Format: gb4e\n% Document ID: ${report.igtxDocument?.document_id || 'unknown'}\n\n${latexBlocks}`;
             type = 'application/x-latex';
             ext = 'tex';
             break;
        case 'elan':
             // Minimal ELAN EAF XML
             content = `<?xml version="1.0" encoding="UTF-8"?>
<ANNOTATION_DOCUMENT DATE="${new Date().toISOString()}" AUTHOR="Dziltoo_Parser" FORMAT="3.0" VERSION="3.0">
    <HEADER MEDIA_FILE="" TIME_UNITS="milliseconds"/>
    <TIME_ORDER/>
    <TIER TIER_ID="txt" LINGUISTIC_TYPE_REF="default-lt">
        ${report.blocks.map((b, i) => `
        <ANNOTATION>
            <ALIGNABLE_ANNOTATION ANNOTATION_ID="a${i+1}" TIME_SLOT_REF1="ts${i+1}" TIME_SLOT_REF2="ts${i+2}">
                <ANNOTATION_VALUE>${b.extractedLanguageLine.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</ANNOTATION_VALUE>
            </ALIGNABLE_ANNOTATION>
        </ANNOTATION>`).join('')}
    </TIER>
    <LINGUISTIC_TYPE GRAPHIC_REFERENCES="false" LINGUISTIC_TYPE_ID="default-lt" TIME_ALIGNABLE="true"/>
    <CONSTRAINT DESCRIPTION="Time subdivision of parent annotation's time interval, no time gaps allowed within this interval" STEREOTYPE="Time_Subdivision"/>
</ANNOTATION_DOCUMENT>`;
             type = 'text/xml';
             ext = 'eaf';
             break;
        case 'flex':
             // SFM (Standard Format Markers)
             content = `\\_sh v3.0  400  Dziłtǫ́ǫ́ Export\n\\_DateStamp ${new Date().toISOString()}\n\n` + 
             report.blocks.map(b => 
`\\ref ${b.lineNumber}
\\t ${b.extractedLanguageLine}
\\note Confidence: ${b.confidence.toFixed(2)}
`).join('\n');
             type = 'text/plain';
             ext = 'db';
             break;
    }

    return { content, type, ext };
}
